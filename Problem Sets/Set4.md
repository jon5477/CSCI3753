1. (+12) Describe at least 3 general approaches in memory management
than can help solve the external fragmentation problem.

=======
* Compaction:
 * Full Compaction: Move all allocated memory to one side of memory (fix fragmentation) and release the old allocated memory processes.
 * Partial Compaction: Move allocated memory and free up memory segments until you have enough memory to honor memory requests.
 * With Swapping: Move allocated memory to disk, free up memory after, then reallocate memory with the disk allocated memory contents.
* Paging: Divide the system memory into fixed size pages, selectively allocating pages to frames (a piece/segment of a physical memory), and manage pages in memory with pointers.
* Garbage Collection: Maintain a reference to unused and inaccessible allocated memory and treat it as free memory.

=======
2. (+12) A memory manager for a variable-sized region strategy has a
free list of blocks of size 600, 400, 1000, 2200, 1600, and 1050
bytes. What block will be selected to honor a request for:
=======

a. 1603 bytes using a best-fit policy? 2200
b. 949 bytes using a best-fit policy? 1000
c. 1603 bytes using a worst-fit policy? 2200
d. 349 bytes using a worst-fit policy? 2200
e. 1603 bytes using a first-fit policy? (assume the free list is ordered
as listed above) 2200
f. 1049 using a first-fit policy? 2200

======
3. (+20) Suppose two processes need to be mapped into main memory
using pages. Process P1 consists of 7 pages, and process P2
consists of 4 pages. Assume main memory consists of 16 frames, a
logical page is the same size as a physical frame, and that 4
entries in a page table fills up a frame of memory. Assume also
that within the process' allocated address spaces, there are two
pages of shared code 'X' and 'Y' common to both address spaces.
Design a memory management system that can store these two
processes and their page tables in RAM. Identify which frames you
have chosen to assign to which process pages and page tables in
main memory/RAM. Also show possible page tables for P1 and P2
(e.g. page table for P1 should have 7 entries).

=====


=====
4. (+12) Suppose on-demand paging is employed in addition to TLB
caching. The time for a TLB hit is T = 1 ns, a memory read M = 10
ns, and a disk read D = 10 ms. Let p_TLB = the probability of a
TLB hit, and p = the probability of a page fault given a TLB miss.
What is a general formula for the average memory access time
expressed as a function of T, M, D, p, and p_TLB? Once parameter
values are substituted, and assuming assuming p = .001 and p_TLB =
90%, what is the calculated average memory access time?

=====


=====
5. (+12) The Least Recently Used (LRU) page replacement policy does not
suffer from Belady's Anomaly. Explain intuitively why this is the
case. Construct an example page fault sequence to illustrate your
point.

=====


=====
6. (+20) Given a frame allocation of 3, and the following sequence of
page references 3 2 4 3 4 2 2 3 4 5 6 7 7 6 5 4 5 6 7 2 1, and
assuming main memory is initially unloaded, show the page faulting
behavior using the following page replacement policies. How many 
page faults are generated by each page replacement algorithm? Which
generates the fewest page faults?
a. FIFO 
b. OPT 
c. LRU

=====


=====
7. (+12) Assume the same sequence of page references as in problem #6,
and assume memory is initially unloaded, but now assume that a dynamic
paging working-set algorithm is applied to the same sequence of
page references, with a window size of 6. Draw the page faulting
behavior. Your solution chart should show the frame allocation at
any given time to the process.

=====


=====
